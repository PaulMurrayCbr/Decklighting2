# CMAKE generated file: DO NOT EDIT!
# Generated by "Unix Makefiles" Generator, CMake Version 4.1

# Default target executed when no arguments are given to make.
default_target: all

#=============================================================================
# Set environment variables for the build.

# The shell in which to execute make rules.
SHELL = /bin/bash
UNAME_S := $(shell uname -s)

ifeq ($(UNAME_S),Darwin)
    SRCDIRS := src/core src/lib src/osx
    CXX := clang++
    CXXFLAGS := -std=c++11 -DHTTP_HOST=\"Sally.local\" -DHTTP_PORT=8080
    CXXLIBS :=
else ifeq ($(UNAME_S),Linux)
    SRCDIRS := src/core src/lib src/pi
    
#    CXXFLAGS := -std=c++11 -I../rpi_ws281x -L../rpi_ws281x -lws2811 -lm -pthread
    CXXFLAGS := -std=c++11  -lm -pthread  -DHTTP_HOST=\"neopixel.local\" -DHTTP_PORT=80
    CXXLIBS := /home/p/rpi_ws281x/libws2811.a
else
    $(error Unsupported platform: $(UNAME_S))
endif

# Collect all .cpp files in the chosen directories
SOURCES := $(foreach dir,$(SRCDIRS),$(wildcard $(dir)/*.cpp))
OBJECTS := $(SOURCES:.cpp=.o)
EXECUTABLE := decklighting2

TESTS := $(wildcard test/*.sh)
TESTRESULTS := $(TESTS:.sh=.test)


# default git label
LABEL=Makefile build succeeded

# The main clean target
clean:
	rm -f $(OBJECTS) $(EXECUTABLE)

VERSION.mk:
	@VER=$$(git describe --tags --abbrev=0 release 2>/dev/null || echo "0.0.0"); \
	VER=$$(echo $$VER | sed 's/^v//'); \
	MAJOR=$$(echo $$VER | cut -d. -f1); \
	MINOR=$$(echo $$VER | cut -d. -f2); \
	PATCH=$$(echo $$VER | cut -d. -f3); \
	NEXT_PATCH="$${MAJOR}.$${MINOR}.$$((PATCH+1))"; \
	NEXT_MINOR="$${MAJOR}.$$((MINOR+1)).0"; \
	NEXT_MAJOR="$$((MAJOR+1)).0.0"; \
	echo "VER=$$VER" > $@; \
	echo "MAJOR=$$MAJOR" >> $@; \
	echo "MINOR=$$MINOR" >> $@; \
	echo "PATCH=$$PATCH" >> $@; \
	echo "NEXT_PATCH=$$NEXT_PATCH" >> $@; \
	echo "NEXT_MINOR=$$NEXT_MINOR" >> $@; \
	echo "NEXT_MAJOR=$$NEXT_MAJOR" >> $@	
	
-include VERSION.mk
	
# Help Target
help:
	@echo
	@echo -e "Decklighting2 - raspberry pi / react implemetation of the decklighting"
	@echo "Version $(VER)"
	@echo "Next patch $(NEXT_PATCH)"
	@echo "Next minor $(NEXT_MINOR)"
	@echo "Next major $(NEXT_MAJOR)"
	@echo
	@echo -e "targets:"
	@echo -e "\tall:\tbuild the decklighting2 executable (default)"
	@echo -e "\tclean"
	@echo -e "\thelp:\tthis help"
	@echo -e "\ttest: run the tests $(TESTRESULTS)"
	

all: clear $(EXECUTABLE) maybe_doc # maybe_save

ifeq ($(UNAME_S),Darwin)
maybe_save: save
else
maybe_save: 
endif

ifeq ($(UNAME_S),Darwin)
maybe_doc: doc
else
maybe_doc: 
endif

ifeq ($(UNAME_S),Darwin)
maybe_test: test
else
maybe_test: 
endif

save: $(EXECUTABLE) maybe_test
	$(MAKE) forcesave
	
forcesave:
	@CURRENT_BRANCH=$$(git symbolic-ref --short HEAD); \
	if [ "$$CURRENT_BRANCH" != "main" ]; then \
		echo "Error: you must be on branch 'main' to save." >&2; \
		exit 1; \
	fi
		@if [ -z "$(LABEL)" ]; then \
	    echo "Error: LABEL cannot be blank"; \
	    exit 1; \
	fi
	git add .
	git commit -m "$(LABEL)" && git push --all || true
	
push: clean $(EXECUTABLE) save
	@if [ "$(LABEL)" = "Makefile build succeeded" ]; then \
	    echo "Error: Set LABEL'"; \
	    exit 1; \
	fi
	git branch -f "feature/$(shell echo $(LABEL) | sed -E 's/ +/-/g')"
	
	git checkout main
	git show-ref --quiet refs/heads/saved || git branch saved
	git show-ref --quiet refs/heads/temp-squash && git branch -D temp-squash || true
	git checkout main
	git checkout -b temp-squash
	git reset --soft saved
	git commit -m "$(LABEL)"
	git checkout saved
	git merge --ff-only temp-squash
	git branch -D temp-squash
	git checkout main
	git push --all
	git checkout main

send:
	rsync -av --exclude='*.o' src/ p@neopixel.local:/home/p/decklighting2/src
	rsync -av web/ p@neopixel.local:/home/p/decklighting2/web
	rsync -av Makefile p@neopixel.local:/home/p/decklighting2/Makefile


patch: VERSION.mk save
	@$(MAKE) do-release NEW_TAG=$(NEXT_PATCH)

release: VERSION.mk save
	@$(MAKE) do-release NEW_TAG=$(NEXT_MINOR)

do-release:
	git diff-index --quiet HEAD -- && git diff-files --quiet || (echo "Working directory has changes/untracked files, aborting release." >&2; exit 1)
	@echo "will release as tag $(NEW_TAG)"
	git checkout release
	git merge --squash main
	git commit -m "$(NEW_TAG)"
	git tag "$(NEW_TAG)"
	git branch -f main
	git checkout main
	@for remote in $$(git remote); do \
    	git push -f $$remote main \
    	git push -f $$remote release \
    	git push $$remote "$(NEW_TAG)"; \
	done

$(EXECUTABLE): $(OBJECTS)
	$(CXX) $(CXXFLAGS) -o $@ $^ $(CXXLIBS)

%.o: %.cpp
	$(CXX) $(CXXFLAGS) -c -o $@ $<

clear:
	clear && printf '\e[3J'

doc: src/core/doc.png

src/core/doc.png: src/core/doc.dot
	dot -Tpng -o $@ $<

test: clear $(TESTRESULTS) $(EXECUTABLE)

test/%.test: $(EXECUTABLE)
	@chmod +x $(@:.test=.sh)
	@./decklighting2 > /dev/null 2>&1 & SERVER_PID=$$!; \
		trap "kill $$SERVER_PID 2>/dev/null; wait $$SERVER_PID" EXIT; \
		sleep 1 ; \
		/bin/bash -c $(@:.test=.sh)
		

